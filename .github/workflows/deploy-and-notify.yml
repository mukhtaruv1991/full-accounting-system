name: Deploy to Render and Notify

on:
  push:
    branches:
      - main

jobs:
  # --- JOB FOR BACKEND ---
  deploy-backend:
    name: Deploy Backend
    runs-on: ubuntu-latest
    steps:
      - name: 1. Install jq
        run: sudo apt-get -y install jq

      - name: 2. Deploy and Send Detailed Notifications
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          RENDER_SERVICE_ID: ${{ secrets.RENDER_BACKEND_SERVICE_ID }}
          SERVICE_NAME: "Backend"
        run: |
          # --- Helper functions for Telegram ---
          send_initial_message() {
            TEXT="$1"
            RESPONSE=$(curl -s -X POST "https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/sendMessage" -d chat_id="$TELEGRAM_CHAT_ID" -d parse_mode="Markdown" -d text="$TEXT")
            echo "$RESPONSE" | jq -r '.result.message_id'
          }
          update_message() {
            MESSAGE_ID="$1"
            TEXT="$2"
            curl -s -X POST "https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/editMessageText" -d chat_id="$TELEGRAM_CHAT_ID" -d message_id="$MESSAGE_ID" -d parse_mode="Markdown" -d text="$TEXT" >/dev/null
          }

          # --- Main Logic ---
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          COMMIT_URL="${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }}"
          ACTION_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          
          # 1. Send initial message
          MSG_ID=$(send_initial_message "‚è≥ *Triggering Deploy* for *$SERVICE_NAME*...")

          # 2. Trigger deploy
          deploy_response=$(curl -s -w "\n%{http_code}" -X POST -H "Authorization: Bearer $RENDER_API_KEY" -H "Accept: application/json" "https://api.render.com/v1/services/$RENDER_SERVICE_ID/deploys")
          http_code=$(echo "$deploy_response" | tail -n1)
          body=$(echo "$deploy_response" | sed '$d')

          if [ "$http_code" -ne 201 ]; then
            update_message "$MSG_ID" "‚ùå *Trigger Failed* for *$SERVICE_NAME*.\n\nCould not start deployment on Render. Check your API Key and Service ID.\n\n*Logs:* [View Action]($ACTION_URL)"
            exit 1
          fi
          deploy_id=$(echo "$body" | jq -r '.id')
          
          # 3. Poll for status and update message
          final_status="unknown"
          build_notified=false
          for i in {1..60}; do
            poll_response=$(curl -s -H "Authorization: Bearer $RENDER_API_KEY" "https://api.render.com/v1/services/$RENDER_SERVICE_ID/deploys/$deploy_id")
            status=$(echo "$poll_response" | jq -r '.status')
            
            # Notify on build start
            if [ "$status" == "build_in_progress" ] && [ "$build_notified" == false ]; then
              update_message "$MSG_ID" "üèóÔ∏è *Build in Progress* for *$SERVICE_NAME* on Render..."
              build_notified=true
            fi
            
            # Check for final status
            if [[ "$status" == "live" || "$status" == "build_failed" || "$status" == "deploy_failed" || "$status" == "canceled" ]]; then
              final_status=$status
              break
            fi
            sleep 10
          done

          # 4. Send final notification
          if [ "$final_status" == "live" ]; then
            FINAL_TEXT="‚úÖ *Deploy Succeeded* for *$SERVICE_NAME*.\n\n*Commit:* [$SHORT_SHA]($COMMIT_URL)"
          else
            ERROR_REASON=$(echo "$poll_response" | jq -r '.error.message // "No details available"')
            FINAL_TEXT="‚ùå *Deploy Failed* for *$SERVICE_NAME* with status: \`$final_status\`.\n\n*Reason:* \`$ERROR_REASON\`\n\n*Logs:* [View Action]($ACTION_URL)"
          fi
          update_message "$MSG_ID" "$FINAL_TEXT"
          
          if [ "$final_status" != "live" ]; then exit 1; fi

  # --- JOB FOR FRONTEND (Identical logic) ---
  deploy-frontend:
    name: Deploy Frontend
    runs-on: ubuntu-latest
    steps:
      - name: 1. Install jq
        run: sudo apt-get -y install jq

      - name: 2. Deploy and Send Detailed Notifications
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          RENDER_SERVICE_ID: ${{ secrets.RENDER_FRONTEND_SERVICE_ID }}
          SERVICE_NAME: "Frontend"
        run: |
          # --- Helper functions for Telegram ---
          send_initial_message() {
            TEXT="$1"
            RESPONSE=$(curl -s -X POST "https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/sendMessage" -d chat_id="$CHAT_ID" -d parse_mode="Markdown" -d text="$TEXT")
            echo "$RESPONSE" | jq -r '.result.message_id'
          }
          update_message() {
            MESSAGE_ID="$1"
            TEXT="$2"
            curl -s -X POST "https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/editMessageText" -d chat_id="$CHAT_ID" -d message_id="$MESSAGE_ID" -d parse_mode="Markdown" -d text="$TEXT" >/dev/null
          }

          # --- Main Logic ---
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          COMMIT_URL="${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }}"
          ACTION_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          
          # 1. Send initial message
          MSG_ID=$(send_initial_message "‚è≥ *Triggering Deploy* for *$SERVICE_NAME*...")

          # 2. Trigger deploy
          deploy_response=$(curl -s -w "\n%{http_code}" -X POST -H "Authorization: Bearer $RENDER_API_KEY" -H "Accept: application/json" "https://api.render.com/v1/services/$RENDER_SERVICE_ID/deploys")
          http_code=$(echo "$deploy_response" | tail -n1)
          body=$(echo "$deploy_response" | sed '$d')

          if [ "$http_code" -ne 201 ]; then
            update_message "$MSG_ID" "‚ùå *Trigger Failed* for *$SERVICE_NAME*.\n\nCould not start deployment on Render. Check your API Key and Service ID.\n\n*Logs:* [View Action]($ACTION_URL)"
            exit 1
          fi
          deploy_id=$(echo "$body" | jq -r '.id')
          
          # 3. Poll for status and update message
          final_status="unknown"
          build_notified=false
          for i in {1..60}; do
            poll_response=$(curl -s -H "Authorization: Bearer $RENDER_API_KEY" "https://api.render.com/v1/services/$RENDER_SERVICE_ID/deploys/$deploy_id")
            status=$(echo "$poll_response" | jq -r '.status')
            
            # Notify on build start
            if [ "$status" == "build_in_progress" ] && [ "$build_notified" == false ]; then
              update_message "$MSG_ID" "üèóÔ∏è *Build in Progress* for *$SERVICE_NAME* on Render..."
              build_notified=true
            fi
            
            # Check for final status
            if [[ "$status" == "live" || "$status" == "build_failed" || "$status" == "deploy_failed" || "$status" == "canceled" ]]; then
              final_status=$status
              break
            fi
            sleep 10
          done

          # 4. Send final notification
          if [ "$final_status" == "live" ]; then
            FINAL_TEXT="‚úÖ *Deploy Succeeded* for *$SERVICE_NAME*.\n\n*Commit:* [$SHORT_SHA]($COMMIT_URL)"
          else
            ERROR_REASON=$(echo "$poll_response" | jq -r '.error.message // "No details available"')
            FINAL_TEXT="‚ùå *Deploy Failed* for *$SERVICE_NAME* with status: \`$final_status\`.\n\n*Reason:* \`$ERROR_REASON\`\n\n*Logs:* [View Action]($ACTION_URL)"
          fi
          update_message "$MSG_ID" "$FINAL_TEXT"
          
          if [ "$final_status" != "live" ]; then exit 1; fi
