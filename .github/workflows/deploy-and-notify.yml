name: Deploy to Render and Notify

on:
  push:
    branches:
      - main

jobs:
  deploy:
    name: Deploy and Notify
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service:
          - name: "Backend"
            id: ${{ secrets.RENDER_BACKEND_SERVICE_ID }}
          - name: "Frontend"
            id: ${{ secrets.RENDER_FRONTEND_SERVICE_ID }}

    steps:
      - name: 1. Install jq
        run: sudo apt-get -y install jq

      - name: 2. Trigger Deploy on Render
        id: trigger
        run: |
          echo "Triggering deploy for ${{ matrix.service.name }}..."
          
          # Send the request and capture the full response and HTTP code
          response=$(curl -s -w "\n%{http_code}" -X POST \
            -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
            -H "Accept: application/json" \
            "https://api.render.com/v1/services/${{ matrix.service.id }}/deploys")
          
          # Separate body and HTTP code
          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')

          # Check for errors
          if [ "$http_code" -ne 201 ]; then
            echo "::error::Failed to trigger deploy. HTTP Status: $http_code"
            echo "::error::Response from Render: $body"
            exit 1
          fi

          deploy_id=$(echo "$body" | jq -r '.id')
          echo "Deploy successfully triggered for ${{ matrix.service.name }} with ID: $deploy_id"
          echo "deploy_id=$deploy_id" >> $GITHUB_ENV

      - name: 3. Wait and Poll for Deploy Status
        id: poll
        run: |
          echo "Waiting for deployment to complete..."
          for i in {1..60}; do
            response=$(curl -s -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" "https://api.render.com/v1/services/${{ matrix.service.id }}/deploys/${{ env.deploy_id }}")
            status=$(echo $response | jq -r '.status')
            echo "Current status for ${{ matrix.service.name }}: $status"
            if [[ "$status" == "live" || "$status" == "build_failed" || "$status" == "deploy_failed" || "$status" == "canceled" ]]; then
              echo "Final status detected: $status"
              echo "final_status=$status" >> $GITHUB_ENV
              exit 0
            fi
            sleep 10
          done
          echo "::error::Polling timed out after 10 minutes."
          echo "final_status=timed_out" >> $GITHUB_ENV
          exit 1
        continue-on-error: true

      - name: 4. Send Telegram Notification
        if: always()
        run: |
          STATUS=${{ steps.poll.outputs.final_status || 'trigger_failed' }}
          SERVICE_NAME="${{ matrix.service.name }}"
          REPO_NAME="${{ github.repository }}"
          COMMIT_URL="${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }}"
          ACTION_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          
          if [ "$STATUS" == "live" ]; then
            ICON="‚úÖ"
            MESSAGE="üöÄ *Deploy Succeeded* for *$SERVICE_NAME*"
          else
            ICON="‚ùå"
            MESSAGE="üö® *Deploy Failed* for *$SERVICE_NAME* with status: \`$STATUS\`"
          fi
          
          TEXT="$ICON $MESSAGE%0A%0A*Repository:* [$REPO_NAME](${{ github.server_url }}/$REPO_NAME)%0A*Commit:* [${{ github.sha:0:7 }}]($COMMIT_URL)%0A*Logs:* [View Action]($ACTION_URL)"
          
          curl -s -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
            -d "chat_id=${{ secrets.TELEGRAM_CHAT_ID }}" \
            -d "text=$TEXT" \
            -d "parse_mode=Markdown"
